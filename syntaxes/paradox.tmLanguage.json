{
	"version": "https://github.com/dragon-archer/paradox-highlight/blob/master/syntaxes/paradox.tmLanguage.json",
	"$schema": "https://raw.githubusercontent.com/RedCMD/TmLanguage-Syntax-Highlighter/main/vscode.tmLanguage.schema.json",
	"name": "Paradox Script Language",
	"scopeName": "source.paradox",
	"uuid": "24081801-bdcf-11ee-8000-44e517e8033d",
	"patterns": [
		{ "include": "#namespace" },
		{ "include": "#code" }
	],
	"repository": {
		"block": {
			"comment": "= block",
			"begin": "(?<==)\\s*({)",
			"beginCaptures": { "1": { "name": "punctuation.section.block.begin.paradox" } },
			"end": "}",
			"endCaptures": { "0": { "name": "punctuation.section.block.end.paradox" } },
			"contentName": "meta.block.paradox",
			"patterns": [ { "include": "#code" } ]
		},
		"code": {
			"comment": "This is the main entry-point",
			"patterns": [
				{ "include": "#comment" },
				{ "include": "#statement" },
				{ "include": "#rhs-item" }
			]
		},
		"comment": {
			"comment": "A line starting with # is a comment",
			"begin": "#",
			"end": "$\\n?",
			"name": "comment.line.number-sign.paradox"
		},
		"comparable-lhs": {
			"comment": "LHS + comparison operator",
			"begin": "\\s*(?=[\\w:.|$]+\\s*(?:<=|>=|!=|<|>))",
			"end": "\\s*(<=|>=|!=|<|>)",
			"endCaptures": { "1": { "name": "punctuation.comparison.paradox" } },
			"contentName": "meta.lhs.comparable.paradox",
			"patterns": [
				{ "include": "#prefix-scopes" },
				{ "include": "#non-prefixable-comparable-lhs" },
				{ "include": "#prefixable-comparable-lhs" }
			]
		},
		"comparable-rhs": {
			"begin": "(?<=<=|>=|!=|<|>)\\s*(?=[^{\\s])",
			"end": "\\s+",
			"contentName": "meta.id.paradox.rhs.comparable",
			"patterns": [
				{ "include": "#numeric" },
				{ "include": "#prefix-scopes" },
				{ "include": "#non-prefixable-comparable-rhs" },
				{ "include": "#prefixable-comparable-rhs" }
			]
		},
		"identifier": {
			"patterns": [
				{ "include": "#macro" },
				{
					"match": "\\b[\\w:|]+\\b",
					"name": "variable.other.identifier.paradox"
				}
			]
		},
		"lhs": {
			"patterns": [
				{ "include": "#non-comparable-lhs" },
				{ "include": "#comparable-lhs" }
			]
		},
		"macro": {
			"match": "(\\$)[\\w:|]+(\\$)",
			"name": "markup.italic variable.parameter.macro.paradox",
			"captures": {
				"1": { "name": "punctuation.definition.macro.begin.paradox" },
				"2": { "name": "punctuation.definition.macro.end.paradox" }
			}
		},
		"namespace": {
			"comment": "Namespace at top of events",
			"match": "^\\s*((namespace)\\s*[=]\\s*([\\w.]+))",
			"name": "meta.namespace.paradox",
			"captures": {
				"1": { "name": "meta.namespace.identifier.paradox" },
				"2": { "name": "keyword.other.namespace.paradox" },
				"3": { "name": "entity.name.type.namespace.paradox" }
			}
		},
		"non-comparable-lhs": {
			"comment": "LHS + =",
			"begin": "\\s*(?=[\\w:.|$@]+\\s*(?:\\?=|=))",
			"end": "\\s*(\\?=|=)",
			"endCaptures": { "1": { "name": "punctuation.equal.paradox" } },
			"contentName": "meta.lhs.non-comparable.paradox",
			"patterns": [
				{ "include": "#prefix-scopes" },
				{ "include": "#non-prefixable-non-comparable-lhs" },
				{ "include": "#prefixable-non-comparable-lhs" }
			]
		},
		"non-comparable-rhs": {
			"begin": "(?<=\\?=|=)\\s*(?=[^{\\s])",
			"end": "\\s+",
			"contentName": "meta.id.paradox.rhs.non-comparable",
			"patterns": [
				{ "include": "#numeric" },
				{ "include": "#prefix-scopes" },
				{ "include": "#non-prefixable-non-comparable-rhs" },
				{ "include": "#prefixable-non-comparable-rhs" }
			]
		},
		"non-prefixable-comparable-lhs": {
			"begin": "(?<!\\.)(?=[\\w:|$]+)",
			"end": "(?![\\w:|$])",
			"contentName": "meta.id.paradox.comparable.non-prefixed",
			"patterns": [ { "include": "#prefixable-comparable-lhs" } ]
		},
		"non-prefixable-comparable-rhs": {
			"begin": "(?<!\\.)(?=[\\w:|$@]+)",
			"end": "(?![\\w:|$@])",
			"contentName": "meta.id.paradox.rhs.comparable.non-prefixed",
			"patterns": [
				{ "include": "#script_constants" },
				{ "include": "#numeric" },
				{ "include": "#prefixable-comparable-rhs" }
			]
		},
		"non-prefixable-non-comparable-lhs": {
			"begin": "(?<!\\.)(?=[\\w:|$@]+)",
			"end": "(?![\\w:|$@])",
			"contentName": "meta.id.paradox.non-comparable.non-prefixed",
			"patterns": [
				{
					"comment": "Numbers",
					"match": "\\b\\d+\\b",
					"name": "constant.numeric.paradox"
				},
				{
					"comment": "LHS boolean operators",
					"match": "(?i)\\b(or|and|not|nor|nand)\\b",
					"name": "markup.bold keyword.operator.logical.paradox"
				},
				{
					"comment": "Other LHS operators",
					"match": "\\b(limit|if|else|else_if|trigger_if|trigger_else|trigger_else_if|while|switch|alternative_limit)\\b",
					"name": "markup.bold keyword.control.flow.paradox"
				},
				{
					"match": "\\b(add_to_temporary_list|assert_if|assert_read|custom_description|custom_tooltip|debug_log|save_temporary_opinion_value_as|save_temporary_scope_as|save_temporary_scope_value_as)\\b",
					"name": "markup.bold variable.language.multi.paradox"
				},
				{ "include": "#script_constants" },
				{ "include": "#prefixable-non-comparable-lhs" },
				{ "include": "#non-prefixable-comparable-lhs" }
			]
		},
		"non-prefixable-non-comparable-rhs": {
			"begin": "(?<!\\.)(?=[\\w:|$\"@]+)",
			"end": "(?![\\w:|$\"@])",
			"contentName": "meta.id.paradox.rhs.non-comparable.non-prefixed",
			"patterns": [
				{
					"match": "\\b(yes|no)\\b",
					"name": "markup.bold constant.language.paradox"
				},
				{ "include": "#strings" },
				{ "include": "#prefixable-non-comparable-rhs" },
				{ "include": "#non-prefixable-comparable-rhs" }
			]
		},
		"numeric": {
			"patterns": [
				{
					"comment": "Dot-seperated date (1000.10.10)",
					"match": "\\b\\d+\\.\\d+\\.\\d+\\b",
					"name": "constant.numeric.date.paradox"
				},
				{
					"comment": "A RHS number, either integer or float, positive or negative",
					"match": "-?(?:(?:\\d+(?:\\.\\d+)?%?)|(?:\\.\\d+))",
					"name": "constant.numeric.paradox"
				}
			]
		},
		"prefix-scopes": {
			"begin": "(?=[\\w:|$]+\\.)",
			"end": "\\.",
			"endCaptures": { "0": { "name": "punctuation.dot.paradox" } },
			"contentName": "meta.scope.paradox",
			"patterns": [
				{ "include": "#scope" },
				{ "include": "#identifier" }
			]
		},
		"prefixable-comparable-lhs": {
			"begin": "(?=[\\w:|$]+)",
			"end": "(?![\\w:|$])",
			"contentName": "meta.id.paradox.comparable.prefixed",
			"patterns": [
				{ "include": "#scope" },
				{ "include": "#identifier" }
			]
		},
		"prefixable-comparable-rhs": {
			"begin": "(?=[\\w:|$]+)",
			"end": "(?![\\w:|$])",
			"contentName": "meta.id.paradox.rhs.comparable.prefixed",
			"patterns": [
				{ "include": "#scope" },
				{ "include": "#identifier" }
			]
		},
		"prefixable-non-comparable-lhs": {
			"begin": "(?=[\\w:|$]+)",
			"end": "(?![\\w:|$])",
			"contentName": "meta.id.paradox.non-comparable.prefixed",
			"patterns": [
				{ "include": "#scope" },
				{ "include": "#prefixable-comparable-lhs" }
			]
		},
		"prefixable-non-comparable-rhs": {
			"begin": "(?=[\\w:|$]+)",
			"end": "(?![\\w:|$])",
			"contentName": "meta.id.paradox.rhs.non-comparable.prefixed",
			"patterns": [
				{ "include": "#scope" },
				{ "include": "#prefixable-comparable-rhs" }
			]
		},
		"rhs": {
			"patterns": [
				{ "include": "#block" },
				{ "include": "#comparable-rhs" },
				{ "include": "#non-comparable-rhs" }
			]
		},
		"rhs-item": {
			"patterns": [
				{ "include": "#numeric" },
				{ "include": "#strings" },
				{ "include": "#identifier" }
			]
		},
		"scope": {
			"comment": "Original relative scope change",
			"match": "(?i)\\b(root|from|prev|this)\\b",
			"name": "markup.bold support.type.scope.paradox"
		},
		"script_constants": {
			"comment": "A predef script variable (@variable)",
			"match": "(?<!\\w)@\\w+",
			"name": "variable.language.predef.paradox"
		},
		"statement": {
			"patterns": [
				{ "include": "#lhs" },
				{ "include": "#rhs" }
			]
		},
		"strings": {
			"begin": "\"",
			"beginCaptures": { "0": { "name": "punctuation.definition.string.begin.paradox" } },
			"end": "\"",
			"endCaptures": { "0": { "name": "punctuation.definition.string.end.paradox" } },
			"name": "string.quoted.double.paradox",
			"patterns": [
				{
					"match": "\\\\.",
					"name": "constant.character.escape.paradox"
				}
			]
		}
	}
}
